---
title: "Working with datasets in R and the Tidyverse"
subtitle: "Summarising data"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
date: "27th May 2021"
editor_options: 
  chunk_output_type: inline
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

> **Questions**
>
> How can I create summary tables of my data?
>
> How do I format my data so I get the tidy summaries?
>
> **Objectives**
>
> To be able to understand how to group data to create convenient summaries.
>
> To be able to reshape data to create convenient summaries.
>
> To be able to apply multiple functions to a single summary call to create complex summaries quickly.
>

Next to visualising data, creating summaries of the data in tables is a quick way to get an idea of what type of data you have at hand. It might help you spot incorrect data or extreme outliers, or whether specific analysis approaches are needed.

To summarise data with the tidyverse efficiently, we need to utilise the tools we have learned the previous days, like adding new variables, tidy-selections, pivots and grouping data. All these tools combine amazingly when we start making summaries. 

Let us start from the beginning with summaries, and work our way up to the more complex variations as we go.

First, we must again prepare our workspace with our packages and data.

```{r}
library(tidyverse)
penguins_path <- palmerpenguins::path_to_file("penguins.csv")
penguins <- read.csv(penguins_path, header = TRUE)
```

We should start to feel quite familiar with our penguins by now. Let us start by finding the mean of the bill length

```{r}
penguins %>% 
  summarise(mean(bill_length_mm))
```

`NA`. as we remember, there are some `NA` values in our data. We can omit these by addin the `na.rm = TRUE` argument, which will remove all NA's before calculating the mean.

```{r}
penguins %>% 
  summarise(mean(bill_length_mm, na.rm = TRUE))
```

We have the mean of bill lenght! But it does not look very tidy. We can give the column a name, in the same fashion as we would in `mutate`. Actually, `summarise` in many ways resembles mutate in how it takes it arguments.

```{r}
penguins %>% 
  summarise(bill_length_mean = mean(bill_length_mm, na.rm = TRUE))
```

To this, we can also add, for instance the minmum and maximum values.


```{r}
penguins %>% 
  summarise(
    bill_length_mean = mean(bill_length_mm, na.rm = TRUE),
    bill_length_min = min(bill_length_mm, na.rm = TRUE),
    bill_length_max = max(bill_length_mm, na.rm = TRUE)
  )
```

## **Challenge 1.** {.tabset}

You can run assignments in your own RStudio, or run the first challenge in the summaries tutorial by entering the following in the R console:
```r
learnr::run_tutorial("005-summarising", "swc.tidyverse")
```
(helpers, please paste this into the chat at the right time.)

### Assignment
>
> **1a**: First start by trying to summarise a single column, `bill_length_mm` by calculating its mean.
>
> **1b**: Add a column with the standard deviation of bill length.
>
> **1c**: Now add the same two metrics for  bill depth and give the columns clear names
>

### Solution

```{r "solutions-1"}
## 1a
penguins %>% 
  summarise(mean(bill_length_mm, na.rm = TRUE))

# 1b
penguins %>% 
  summarise(
    mean(bill_length_mm, na.rm = TRUE),
    sd(bill_length_mm, na.rm = TRUE)
  )

## 1c 
penguins %>% 
  summarise(
    bill_length_mean = mean(bill_length_mm, na.rm = TRUE),
    bill_length_sd   = sd(bill_length_mm, na.rm = TRUE),
    bill_depth_mean  = mean(bill_depth_mm, na.rm = TRUE),
    bill_depth_sd    = sd(bill_depth_mm, na.rm = TRUE)
  )
```

Here, we also added some extra space after the column names, to align the functions up.
This is a fairly common coding practise for this type of code, that usually makes it easier for others to read.

# Summarising multiple columns

We've already mentioned that `summarise` accepts arguments much like `mutate` does. Which means that it might also work with across? That would be convenient when we'd like to summarise across many columns at once. 

```{r}
penguins %>% 
  summarise(
    across(starts_with("bill"), 
           .fns = mean)
  )
```

We still have the problem with `NA`s. But, we can use the internal `.x` as we've done before.

```{r}
penguins %>% 
  summarise(
    across(starts_with("bill"), 
           .fns = ~ mean(.x, na.rm = TRUE))
  )
```

The name of the columns are a little unsatisfactory though, they give us no real indication of what the metric is. We can add names , but we'll need to place the function inside a `list()` first. 

```{r}
penguins %>% 
  summarise(
    across(starts_with("bill"), 
           .fns = list(
             mean = ~ mean(.x, na.rm = TRUE)
           )
    )
  )
```

And like with `across` before, we can control how the column names are made by the use of the `.names` argument and knowing the internal placeholders for the names of the columns (".col") and the functions (".fn").


```{r}
penguins %>% 
  summarise(
    across(starts_with("bill"), 
           .fns = list(
             mean = ~ mean(.x, na.rm = TRUE), 
             sd = ~ sd(.x, na.rm = TRUE)
           ),
           .names = "{.fn}_{.col}"
    )
  )
```

Now we know how to summarise several columns at once, and we can even do that with several functions. The last examples we saw, are actually a little over-complicated, because we wanted to make sure you got a feel for how things work. Notice how all the functions we are using take the `na.rm = TRUE` argument to remove NA. This consistency across the three functions makes is possible to let `across` know in one line that all the functions should use this setting.

```{r}
penguins %>% 
  summarise(across(contains("_"), 
                   .fns = list(
                     mean = mean,
                     sd = sd
                   ), 
                   na.rm = TRUE)
  )
```

When we are able to do that, we can drop the `~` and `.x` and just let across know that for all functions, it should remove NAs. This is more concise and easier to read and type!
But remember, this trick only works when using functions that have this same argument in them, and not all functions do.


## **Challenge 2.** {.tabset}

You can run assignments in your own RStudio, or run the first challenge in the summaries tutorial by entering the following in the R console:
```r
learnr::run_tutorial("005-summarising", "swc.tidyverse")
```
(helpers, please paste this into the chat at the right time.)

### Assignment
>
> **2a**: Get the mean of all columns containing an underscore ("_")
>
> **2b**: Get the mean, minimum and maximum of all columns containing an underscore ("_")
>
> **2c**:  Do the same as the above, but now make sure the columns are given nicer names by naming the functions in the list.
>
> **2d**: Simplify the code above to not use the tilde (~) but assign na.rm = TRUE to all functions at once.

### Solution

```{r "solutions-2"}
## 2a
penguins %>% 
  summarise(across(contains("_"), 
                   .fns = ~ mean(.x, na.rm = TRUE)))

# 2b
penguins %>% 
  summarise(across(contains("_"), 
                   .fns = list(
                     ~ mean(.x, na.rm = TRUE),
                     ~ min(.x, na.rm = TRUE),
                     ~ max(.x, na.rm = TRUE)
                   ))
  )

## 2c 
penguins %>% 
  summarise(across(contains("_"), 
                   .fns = list(
                     mean = ~ mean(.x, na.rm = TRUE),
                     min = ~ min(.x, na.rm = TRUE),
                     max = ~ max(.x, na.rm = TRUE)
                   ))
  )

## 2d 
penguins %>% 
  summarise(across(contains("_"), 
                   .fns = list(mean = mean,
                               min = min,
                               max = max), 
                   na.rm = TRUE)
  )
```


# Summarising grouped data

All the examples we have gone through so far with summarising data, we have summarised the entire data set. But most times, we want to have a look at groups in our data, and summarise based on these groups. How can we manage to summarise while preserving grouping information?

We've already worked a little with the `group_by` function, and we will use it again! Because, once we know how to summarise data, summarising data by groups is as simple as adding one more line to our code.

Let us start with our first example of getting the mean of a single column.

```{r}
penguins %>% 
  summarise(
    bill_length_mean = mean(bill_length_mm, na.rm = TRUE)
  )
```

Here, we are getting a single mean for the entire data set. In order to get, for instance the means of each of the species, we can group by species before we summarise.

```{r}
penguins %>% 
  group_by(species) %>% 
  summarise(
    bill_length_mean = mean(bill_length_mm, na.rm = TRUE)
  )
```

And now we suddenly have three means! And they are tidily collected in each their row.
To this we can keep adding as we did before.

```{r}
penguins %>% 
  group_by(species) %>%
  summarise(
    bill_length_mean = mean(bill_length_mm, na.rm = TRUE),
    bill_length_min = min(bill_length_mm, na.rm = TRUE),
    bill_length_max = max(bill_length_mm, na.rm = TRUE)
  )
```

Now we are suddenly able to easily compare groups within our data, since they are so neatly summarised here. 


## **Challenge 3.** {.tabset}

You can run assignments in your own RStudio, or run the third challenge in the summaries tutorial by entering the following in the R console:
```r
learnr::run_tutorial("005-summarising", "swc.tidyverse")
```
(helpers, please paste this into the chat at the right time.)

### Assignment
>
> **3a**: Group the data by species and get the mean of the `bill_length_mm` column
>
> **3b**: Group the data by island instead, and take the summary of the bill length and bill depth columns
>
> **3c**: Group the data by island AND species, what happened? 
>

### Solution

```{r "solutions-3"}
## 3a
penguins %>% 
  group_by(species) %>% 
  summarise(mean(bill_length_mm, na.rm = TRUE))

# 3b
penguins %>% 
  group_by(island) %>% 
  summarise(
    bill_length_mm = mean(bill_length_mm, na.rm = TRUE),
    bill_depth_mm = mean(bill_depth_mm, na.rm = TRUE)
  )

## 3c
penguins %>% 
  group_by(island, species) %>% 
  summarise(
    bill_length_mm = mean(bill_length_mm, na.rm = TRUE),
    bill_depth_mm = mean(bill_depth_mm, na.rm = TRUE)
  )
```

# Summarising collections of columns while grouped
Since we know how to apply the group by function now, we should also be able to apply it before summarising across columns. There is no real difference in the summarise function with or without the across. It basically does the same. So let us also try summarising based on groups using across!
Before we had this code:

```{r}
penguins %>% 
  summarise(across(starts_with("bill"), 
                   .fns = list(mean = mean,
                               min = min,
                               max = max), 
                   na.rm = TRUE)
  )
```

Where we summarised the columns starting with bill, and got the mean, min and max values for those columns, and made sure we removed the NAs. If we want to do this in a grouped fashion, we need to get the group by function snuggled in between the data call to penguins and summarise.

```{r}
penguins %>% 
  group_by(species) %>% 
  summarise(across(starts_with("bill"), 
                   .fns = list(mean = mean,
                               min = min,
                               max = max), 
                   na.rm = TRUE)
  )
```

Now we get a lovely summary of all the columns and functions we want for all three species groups.
We can even combine the single column summaries together with across!

```{r}
penguins %>% 
  group_by(species) %>% 
  summarise(across(starts_with("bill"), 
                   .fns = list(mean = mean,
                               min = min,
                               max = max), 
                   na.rm = TRUE),
            n = length(species)
  )
```

Look at the last column `n`! Now, together with all the bill column and function combinations, we have a single column counting the number of species observations!


## **Challenge 4.** {.tabset}

You can run assignments in your own RStudio, or run the third challenge in the summaries tutorial by entering the following in the R console:
```r
learnr::run_tutorial("005-summarising", "swc.tidyverse")
```
(helpers, please paste this into the chat at the right time.)

### Assignment
>
> **4a**: Get the descriptive statistics (mean, sd, min and max) for all the columns ending with "mm", grouped by species
>
> **4b**: Now add a count of how many observations there are of each species and place that in the column named `n`. 
>
> **4c**: Try grouping by more variables. Like sex, or island. or add more summary variables. 
>

### Solution

```{r "solutions-4"}
## 4a
penguins %>% 
  group_by(species) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE)
  )

# 4b
penguins %>% 
  group_by(species) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE),
            n = length(species)
  )


## 4c
penguins %>% 
  group_by(species, island, sex) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE),
            n = length(species)
  )
```

# Pivoting summaries to get better overview

We now have outputs with lots of information, but its not in the tidiest format. There are just so many columns! We keep having to change lines to see more and more output, and this is just not convenient. We would like to create a more consensed table, but still retaining all the information. We learned about pivoting tables yesterday, so we could to that to our summaries too!

```{r}
penguins %>% 
  group_by(species, island, sex) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE),
            n = length(species)
  ) %>% 
  pivot_longer(contains("mm"))
```

Ok so now everything is back into this pivoting format where things are in two columns. Ok, that is still not very satisfactory though. Let's try to make it better. The naming of columns is still very convenient, so let ut try to split the `name` column up like we did yesterday. 

```{r}
penguins %>% 
  group_by(species, island, sex) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE),
            n = length(species)
  ) %>% 
  pivot_longer(contains("mm"),
               names_to = c("part", "measurement", "unit", "stat"),
               names_sep = "_")
```

Ok, its slightly better, but its still not convenient. Ideally, we'd like the different statistics as different columns, and have the rest in rows. Now that we have split the columns up, we have a column with _just_ the statistics names. Lets try pivoting wider again, using that column to create the column names,

```{r}
penguins %>% 
  group_by(species, island, sex) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE),
            n = length(species)
  ) %>% 
  pivot_longer(contains("mm"),
               names_to = c("part", "measurement", "unit", "stat"),
               names_sep = "_") %>% 
  pivot_wider(names_from = stat, 
              values_from  = value)
```

Look at that! Its starting to become so much better! Now each grouping combination and type of measurement is in its own row, but each summary statistic is in different columns. Slowly, the data are becoming more easy to compare. 


## **Challenge 5.** {.tabset}

You can run assignments in your own RStudio, or run the fifth challenge in the summaries tutorial by entering the following in the R console:
```r
learnr::run_tutorial("005-summarising", "swc.tidyverse")
```
(helpers, please paste this into the chat at the right time.)

### Assignment
>
> **5a**: Pivot longer a grouped summary over species for the columns containing underscores, with the metrics mean, standard deviation, minimum and maximum values. When you pivot the data, split the column names up into 4 parts describing the part, measurement, unit and statistic used. 
>
> **5b**: Add to the code you just wrote and pivot the data wider again by the statistic column.
>

### Solution

```{r "solutions-5"}
## 5a
penguins %>% 
  group_by(species, island, sex) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE)
  ) %>% 
  pivot_longer(contains("mm"),
               names_to = c("part", "measurement", "unit", "stat"),
               names_sep = "_") 

# 5b
penguins %>% 
  group_by(species, island, sex) %>% 
  summarise(across(ends_with("mm"), 
                   .fns = list(mean = mean,
                               sd = sd,
                               min = min,
                               max = max), 
                   na.rm = TRUE),
            n = length(species)
  ) %>% 
  pivot_longer(contains("mm"),
               names_to = c("part", "measurement", "unit", "stat"),
               names_sep = "_") %>% 
  pivot_wider(names_from = stat, 
              values_from  = value)
```
